--- 
layout: default 
section: Section 1 - Unit Testing
parent: Testing / QA
parentUrl: /pages/tutorials/testing/index.html
---
<link rel="stylesheet" href="{{ "/css/syntax.css" | prepend: site.baseurl | prepend: site.url }}">
<link rel="stylesheet" href="{{ "/css/tutorial.css" | prepend: site.baseurl | prepend: site.url }}">

<div id="wrapper" class="extra-large-padding-top">
        
    <!-- Sidebar -->
    <div id="sidebar-wrapper">
        <h1>{{ page.section }}</h1>
        <ol class="sidebar-nav">
            {% for section in site.data.tutorials-testing %}
                {% if section.heading == page.section %}
                    {% for subheading in section.sub-sections %}
                    <li><a href="#{{ subheading.url }}">{{ subheading.heading }}</a></li>
                    {% endfor %}
                {% endif %}
            {% endfor %}
        </ol>
    </div>
    <!-- /#sidebar-wrapper -->

    <!-- Page Content -->
    <div id="page-content-wrapper">
        <div class="container-fluid">
            <div class="row" id="introduction">
                <div class="col-lg-12">
                    <h2>1. Introduction</h2>
                    <p class="question">What are unit tests?</p>
                    <p class="answer">An unit test is simply an automated test of small part of an application, in object-oriented programming this would most commonly be a method, class or interface.</p>
                    <p class="question">Why do we need them?</p>
                    <p class="answer">They are required to prove that the unit of code performs functionally as expected, as a bonus they also show the original intent of the code if there is any ambiguity</p>
                    <p class="question">What is Test Driven Development?</p>
                    <p class="answer">
                        <blockquote cite="https://en.wikipedia.org/wiki/Test-driven_development">
                            <p>
                            Test-driven development (TDD) is a software development process that relies on the repetition of a very short development cycle: Requirements are turned into very specific test cases, then the software is improved to pass the new tests, only. This is opposed to software development that allows software to be added that is not proven to meet requirements.</p>
                            <footer class="left-align-footer"><a href="https://en.wikipedia.org/wiki/Test-driven_development">https://en.wikipedia.org/wiki/Test-driven_development</a></footer>
                        </blockquote>
                        The typical development cycle used with TDD is;
                        <ul>
                            <li>Add a failing test - important to have a failing test to ensure there are no false positives when we run the tests</li>
                            <li>Run the tests</li>
                            <li>Write code to pass the test - first iteration of the code may not be the most performant or elegant solution</li>
                            <li>Run tests</li>
                            <li>Refactor code - Improve performance and design, remove duplication of code, etc.</li>
                            <li>Repeat</li>
                        </ul>
                    </p>
                    <p class="question">Other test frameworks</p>
                    <p class="answer">TestNG, Junit 5</p>
                </div>

            </div>
            

            <div class="row" id="first-test">
                <div class="col-lg-12">
                    <h2>2. Creating first unit test</h2>
                    <p>For the first example we will be implementing the FizzBuzz childrens' game, this is commonly used as interviewing exercise for entry level programming jobs.  A full explanation of the game with various implementations can be found at <a href="https://en.wikipedia.org/wiki/Fizz_buzz">https://en.wikipedia.org/wiki/Fizz_buzz</a>, the rules are pretty simple; given a number output Fizz if the number is divisable by three, output Buzz if divisable by 5 and output Fizz Buz if divisable by 3 and 5 otherwise output the original number.</p>
                    
                    <p>The first step will to be create a new maven project, <a href="../maven/index.html">overview of creating a maven project</a>, setting the properties to;
                       <ul class="no-indent-no-bullets">
                            <li>Group id: <strong>org.daisonp</strong></li>
                            <li>artifact id: <strong>testingexamples</strong></li>
                            <li>version: <strong>0.0.1-SNAPSHOT</strong></li>
                            <li>package: <strong>org.daisonp.testingexamples</strong></li>
                       </ul>
                       This will create a project with the structure
                       <script src="https://gist.github.com/daisonp/22d6607a7a53397e2d421806f1a61bfc.js"></script>
                        Update the pom.xml file to use version 4.12 of JUnit, also replace App.java and AppTest.java files with FizzBuzz.java and FizzBuzzTest.java
                    </p>
                </div>
                <div class="col-lg-6">
                    <H5>FizzBuzz.java</H5>
                    <script src="https://gist.github.com/daisonp/6a526aaa8f5fcfa1960c5539b1612306.js"></script>
                </div>
                <div class="col-lg-6">
                    <H5>FizzBuzzTest.java</H5>
                    <script src="https://gist.github.com/daisonp/0ea7f21598b3f0afa59f4ad820501a4e.js"></script>
                </div>
                <div class="col-lg-12">
                    <p>
                    Once we have the test class we can start to create our tests, any method annotated with @Test will be run by the JUnit framework as a test.  Following the TDD development cycle we will start by creating a failing test that checks that a number is returned when FizzBuzz is run for a number that is not divisable by 3 or 5.
                    </p> 

                    <h4>Adding a failing test</h4>
                    <H5>FizzBuzzTest.java</H5>
                    <script src="https://gist.github.com/daisonp/00ef9aff493397e13c2c098caee110b2.js"></script>
                    <p>The first failure for this code is at compile time and not the actual running of the test as the 'run(int)' method does not actually exist on the FizzBuzz class. We can get the IDE to rectify this issue for us by clicking on the red cross on the line in error and selecting the 'Create method run(int) in type FizzBuzz' option, this will create a template mehtod in the FizzBuzz class that returns a null value.</p> 
                    <p>Now lets looking at the most relevant lines of code in this class
                        <ul>
                            <li>Line 7 - It is a common convention to name the class the same as the Class which is being tested with the additional 'Test' suffix on the class name </li>
                            <li>Line 8 - Create an instance of the class under test - doesn't have to be done as a static variable and in most cases will be create per test</li>
                            <li>Line 10 - @Test annotation indicates that the following method will be run by the JUnit testing framework</li>
                            <li>Line 12 - Execution of the method under test storing the return value in the result variable</li>
                            <li>Line 13 - Assertion checking the returned value matches the expected value, using assertEquals the expected value is the first parameter and the actual value is the second parameter.</li>
                        </ul>
                    </p>
                    <h4>Run the tests</h4>
                    <p>The test class can be run by right clicking on the test class and selecting 'Run As' --> Junit Test. This will then run the tests and report the outcome in a new JUnit view</p>
                    <img src="{{ site.url | prepend: site.base_url }}/img/tutorials/testing/section-1/failing-unit-test.png" alt="Failing unit test" class="img-responsive img-hover"> 
                    <h4>Write code to pass the test</h4>
                    We then change the code in the FizzBuzz.run(int) method to pass the test, this should be the simplest solution at this point and not the whole required functionality
                    <H5>FizzBuzz.java</H5>
                    <script src="https://gist.github.com/daisonp/ff8b3093a1d9e6665ae73c27fd3bc6a0.js"></script>  
                    <h4>Rerun the test</h4>
                    <p>The tests can either be rerun by pressing the 'rerun test' button in the JUnit view or by selecting 'Run as' --> JUnit as done previously.  At this point the tests should pass, if not review the code in FizzBuzz.run(int)
                    </p>
                    <h4>Refactor and repeat</h4>
                    <p>So following the TDD development cycle we have; Added a failing test, run the test, written code to pass the test and re-run the test.  All that is left to do is refactor the code and repeat by the cycle by adding new tests</p>
                    <p>So just using the @Test annotation and the assertEquals assertion we should be able to repeat this process and create tests to test all the required functionality
                        <ul>
                            <li>Input value of 3 outputs a value of Fizz</li>
                            <li>Input value of 5 outputs a value of Buzz</li>
                            <li>Input value of 15 outputs a value of FizzBuzz</li>
                        </ul>
                    </p>
                    <p>At the end of this process you may end up with classes that are similar to these</p>
                    <h5>FizzBuzzTest.java</h5>
                    <script src="https://gist.github.com/daisonp/305980fbdab06303327b479362fafd62.js"></script>
                    <h5>FizzBuzz.java</h5>
                    <script src="https://gist.github.com/daisonp/6d3fdd68c0edc6693b09f816b195c3a6.js"></script>
                    <p>Screen capture video showing creation of the project and the process of going through the TDD development cycle.</p>
                    
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/wPQwwQa22xc" frameborder="0" allowfullscreen></iframe>   
                </div>
            </div>

            <div class="row" id="assertions">
                <div class="col-lg-12">
                    <h2>3. Assertions</h2>
                    <p>Within the JUnit framework an assertion is used to determine whether a test passes or fails, failing assertions throw <code>AssertionError</code> exceptions which allow the framework to mark a test as failed. So far we have only used the assertEquals assertion from the org.junit.Assert class but there are other<a href="http://junit.org/junit4/javadoc/4.12/org/junit/Assert.html" target="_blank"> assertion methods available in the Assert class</a>, below is an example of some of the various methods</p>
                    <script src="https://gist.github.com/daisonp/b166ba1210fb2422b113e0108edebc95.js"></script>
                    <p>There are 2 methods not shown these are fail() which simply throws an <code>AssertionError</code> and assertThat() which uses Hamcrest Matchers.</p>
                    <h4>AssertThat and Hamcrest Matchers</h4>

                    explanation of AssertThat and Matchers goes here
                </div>
            </div>

            <div class="row" id="assumes">
                    <div class="col-lg-12">
                        <h2>4. Assumes</h2>
                        
                    </div>
                </div>

            <div class="row" id="annotations">
                <div class="col-lg-12">
                    <h2>5. Annotations</h2>
                    <p>In the JUnit framework there are a number of hooks into the running livecycle of the tests where we can supply our own code, these hooks are activated by adding annotations to methods.  The available annotations are</p>
                    <dl>
                        <dt>@Test</dt>
                            <dd>
                                Marks a method as a test to be run with the JUnit framework, the method that the annotation applies to must be declared as <code>public</code> with a <code>void</code> return type.
                            </dd>
                        <dt>@Ignore</dt>
                            <dd>
                                Used in conjuntion with <code>@Test</code>, this annotation temporary disables the test but still allows the framework to indicate that there was a test that was not run
                            </dd>
                        <dt>@Before</dt>
                            <dd>
                                Will run the code in the method before each test is called, the method must be <code>public</code> and return <code>void</code>.
                            </dd>
                        <dt>@BeforeClass</dt>
                            <dd>
                                Will run the code <strong>ONCE</strong> at the initializion of the test class, the method this annotation is applied to must be <code>public static</code> and have a <code>void</code> return type.  This is commonly used to setup resource intensive operations that are shared between all the tests in the class,such as a database connection.
                            </dd>
                        <dt>@After</dt>
                            <dd>
                                Runs after each test and is normally used to reset or teardown what is created in a <code>@Before</code> annotated method.  Must be applied to a <code>public</code> method with a <code>void</code> return type;
                            </dd>
                        <dt>@AfterClass</dt>
                            <dd>
                                Runs once at the end of the process and is used to close or teardown any resources created in a method annotated with <code>@BeforeClass</code>
                            </dd>
                        <dt>@FixMethodOrder</dt>
                            <dd> 
                                This is a class level annotation and not method level as all the others have been.  It is used to enable the runnning of the rules in a fixed order, it is recommended not to use this annotation.  All tests should be independant of each other and not rely on the state mutation of a previous test as the starting state of an other test.  
                            </dd>
                    </dl>
                    Below is a simple code example of the use of these annotations just writing a message out to the console to show when each method is called.
                    <script src="https://gist.github.com/daisonp/c7018a0c8be5904d8393b1f4ac4d6049.js"></script>

                    <div class="col-lg-6">
                            <img src="{{ site.url | prepend: site.base_url }}/img/tutorials/testing/section-1/junit-ignored-test.png" alt="Ignored unit test" class="img-responsive img-hover">
                        </div>
                    <div class="col-lg-6">
                         <p>The output of running this test class will be</p>
                        <pre>
@BeforeClass will be run once at the start before any of the tests
@Before runs before each test is executed
This is test 1
@After runs after each test is executed
@Before runs before each test is executed
This is test 2
@After runs after each test is executed
@AfterClass will be run once at the end of all the tests
                        </pre>
                        <p>There are 2 other annotations <code>@Rule</code> and <code>@RunWith</code> which require further explanation</p>
                    </div>
                    
                    
                </div>
            </div>

            <div class="row" id="junit-rules">
                <div class="col-lg-12">
                    <h2>6. JUnit Rules <code>@Rule</code></h2>
                    <pre>
                            DisableOnDebug 
                            ErrorCollector 
                            ExpectedException 
                            ExternalResource 
                            RuleChain 
                            RunRules 
                            Stopwatch 
                            TemporaryFolder 
                            TestName 
                            TestWatcher 
                            TestWatchman 
                            Timeout 
                            Timeout.Builder 
                            Verifier

                    </pre>
                </div>
            </div>

            <div class="row" id="test-runners">
                <div class="col-lg-12">
                    <h2>7. Test Runners <code>@RunWith</code></h2>
                    <pre>
                    7) Test Runners @RunWith
                    a) What are they
                    b) Suite
                    c) Paramertized
                    </pre>

                </div>
            </div>

            <div class="row" id="not-covered">
                <div class="col-lg-12">
                    <h2>8. Features not covered</h2>
                    <pre>
                        Categories
                        Theories    
                    </pre>
                </div>
            </div>
        </div>
    </div>
    <!-- /#page-content-wrapper -->
</div>
<!-- /#wrapper -->